\section{Zusammenfassung und Ausblick}
\label{conclusion}

In den eingangs dokumentierten Interviews wurde festgestellt, dass aktuell die Erstellung und Dokumentation von RPA-Robotern in verschiedenen Programmen erfolgen muss. Mit der vorgestellten Lösung ist es möglich, RPA-Roboter direkt in BPMN zu modellieren und die Automatisierungsfolgen zu implementieren. Zudem ist es durch die SSoT erstmals möglich, denselben Roboter in verschiedenen Modellierungsnotationen und Code-Editoren zu erstellen. Die einheitliche Speicherlösung und das Konzept der Parser ermöglichen darüber hinaus, weitere Modellierungsinterfaces, aber auch Code-Editoren zu ergänzen. Die Anbindung von Modellierungsinterfaces sowie zukünftig einem Low-Code-Editor, wie beipielsweise Google Blockly, ermöglicht auch für Prozessexperten ohne IT-Hintergrund die Erstellung von RPA-Robotern. Ebenso kann ein Entwickler den Roboter direkt im Code erstellen und trotzdem die für Prozessexperten relevante Dokumentation in Form eines BPMN-Diagramms bereitstellen. Sofern gewünscht, könnten Prozessexperten kleinere Änderungen an der Automatisierung in einem für sie geeigneteren Interface direkt vornehmen.

RPA-Automatisierungen sollten aus meiner Sicht in jedem Fall von RPA-Consultants begleitet werden. Andernfalls wird der Schritt der Prozessoptimierung (zum Beispiel mit Process Mining) oftmals vernachlässigt. Auch in den Interviews mit den RPA-Entwicklern wurde deutlich, dass vor jeder Automatisierung mögliches Optimierungspotenzial analysiert wird.

Die aktuelle Implementierung, die für jede Aktivität einen einzelnen Test-Case definiert, unterstützt keine lokalen Variablen, Verzweigungen und Schleifen. Um diese Konstrukte abbilden zu können, muss der RobotFramework-Code auf die Keywords-Syntax umgestellt werden. Wie der Code für unserem Beispielprozess in dieser Syntax strukturiert ist, zeigt der Code-Ausschnitt in Abbildung \ref{fig:ScrRobotFrKeywords}. Die dort vorgestellte Syntax ermöglicht langfristig die Umsetzung aller in dieser Arbeit vorgestellten Konzepte. Durch die Trennung der RPA-Funktionen und der Programmstruktur ist der Code zudem besser lesbar. 
Sofern eine Umstellung auf die Keywords-Syntax erfolgt, ist zu prüfen, ob alle verwendeten Algorithmen zur Rekonstruktion des Graphenmodells korrekt funktionieren. Die bestehenden Tests decken nur sequenzielle Folgen von Anweisungen ab.

\clearpage

Eine durch die SSoT entstehende Einschränkung ist die Abstraktion der Modelle. So kann BPMN in der Standarddefinition deutlich mehr abbilden, als sich aufgrund des SSoT-Modells speichern lässt. Viele Details lassen sich nicht in den Code überführen oder in anderen Modellierungssprachen darstellen. Alle Eigenschaften, die sich nicht auf andere Modellierungsnotationen übertragen lassen, werden nicht in der SSoT gespeichert und stehen daher auch nicht in BPMN zur Verfügung.
Dazu zählen unter anderem wesentliche Dokumentationsfeatures, aber auch Konzepte wie beispielsweise Pools, Lanes und aufklappbare Subprozesse. Letztere können, wie in Abbildung \ref{fig:viadee} erkenntlich, die Übersichtlichkeit der Prozessdarstellung erheblich verbessern. Zudem lassen sich über diese Syntax wiederverwendbare, modulare Roboter abbilden. Diese Funktion passt zur Anforderung von UiPath \cite{uiPathReq}, eine Integrationsmöglichkeit für Roboter aus der \glqq globalen Anwender-Community\grqq{} anzubieten.

Ein möglicher Nachteil der SSoT-Lösung und der damit einhergehenden Nicht-Speicherung von interfacespezifischen Daten ist die automatische Ausrichtung aller Diagrammelemente bei jeder Öffnung des Modelers. Alle Elemente der visuellen Repräsentation - in BPMN - werden jedes Mal neu positioniert. Das kann einerseits gewollt sein, da zum Beispiel das \code{bpmn-js} CLI versucht, alle Elemente strukturiert anzuordnen. Andererseits wird keine manuell gewünschte Änderung in der Anordnung der Elemente gespeichert, wie sie beispielsweise zur besseren Übersicht beim Drucken des Diagramms gewünscht sein kann. Dieses Feature kann sich nur dann umgesetzt werden, wenn die in der Abbildung \ref{fig:parser1} dargestellte Architektur verwendet wird. Dann lässt sich jeder Roboter nur in genau einem Modellierungsinterface erstellen und zu jeder Ausführung in den RobotFramework Code parsen. Da ein Entwicklerteam mit genau einer Modellierungssprache arbeitet, kann sich diese Einschränkung auszahlen.  

Abschließend ist festzuhalten, dass der Wunsch der RPA-Developer nach einer Plattform, die das Erstellen von Robotern mit verschiedenen Modellierungssprachen ermöglicht, erfüllt werden konnte. Hierzu wurde eingehend untersucht, welche Modellierungssprachen sich für die Erstellung der Roboter eignen. Durch die Proof of Concept Implementierung wurde das Konzept der einheitlichen Speicherlösung validiert. Mit der entstandenen Implementierung wurde eine Open-Source-RPA-Plattform geschaffen, die sich um weitere benötigte Interfaces erweitern lässt.